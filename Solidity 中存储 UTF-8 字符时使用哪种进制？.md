# Solidity 中存储 UTF-8 字符时使用哪种进制？

Solidity 实际存储的是：**字节（二进制）**数据，但通常以**十六进制**表示出来。

## 为什么这么说？

- Solidity 是一种智能合约语言，运行在以太坊虚拟机（EVM）上
- EVM 是按字节（byte）为单位处理数据的，每个字节就是 8 位二进制
- 虽然底层是二进制，但在源码或调试/ABI 编码/日志中，**通常用十六进制表示**，因为十六进制更简洁、方便阅读

## 举个例子：“中” 字在 Solidity 中怎么表示？

```solidity
bytes memory a = bytes("中")
```

这个 a 实际是：

```bash
十六进制表示：E4 B8 AD
二进制表示：11100100 10111000 10101101
```

你在调试或 events/logs/存储中，看到的通常是：

```bash
0xe4b8ad
```

总结：

| 表现形式       | 描述                                              |
| -------------- | ------------------------------------------------- |
| **十六进制**   | Solidity 代码中最常见的表现形式，用于 ABI、调试等 |
| **二进制**     | 内存中实际存储的方式，本质都是 0 和 1             |
| **UTF-8 编码** | 定义了字符如何变成字节序列（用于存储）            |

## 在 Solidity 中使用字符串与字节

```solidity
string b = "中";
bytes c = bytes(b);
```

我们可以访问字节内容：

```solidity
c[0] // 0xe4
c[1] // 0xb8
c[2] // 0xad
```

这些就是 UTF-8 编码的十六进制形式：`E4 B8 AD`

> 本质上，字节就是一段二进制数据，1 字节（byte）= 8 位（bit）二进制数

## 为什么通常用十六进制来“表示”字节？

主要是因为：

- 二进制太长太难看清，比如 10101011 不如 AB（十六进制）直观
- 每个十六进制数字正好代表 4 位二进制，2 个十六进制数字正好就是 1 个字节（8 位）

所以我们**虽然操作的是字节（二进制）**，但在代码中写成：

```solidity
bytes memory a = hex"e4b8ad"; // 三个字节，实际存的是 UTF-8 的 "中"
```

此时：

- `a.length == 3`
- `a[0] == 0xe4`
- `a[1] == 0xb8`
- `a[2] == 0xad`

## 补充说明：

Solidity 中的 `hex""` 是一种语法糖，相当于初始化一个 `bytes` 类型数组，里面每两个十六进制字符就是一个字节（byte）。例如：

```solidity
hex"e4b8ad"
```

等价于：

```solidity
bytes memory b = new bytes(3);
b[0] = 0xe4;
b[1] = 0xb8;
b[2] = 0xad;
```

这些字节是直接按顺序排列存储的，因此我们可以使用索引 `b[i]` 访问它们。